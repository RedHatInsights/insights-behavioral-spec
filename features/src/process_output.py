# Copyright Â© 2022, 2023 Pavel Tisnovsky, Red Hat, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Tooling to process output generated by finished process."""
from behave.runner import Context

# Services and tools written in Go can be compiled with -cover compilation option.
# In this case each run of such service/tool will generated code coverage report,
# but only incase GOCOVERDIR environment variable is set up. If not, the binary
# print warning message which we must ignore in several tests (like check if help
# is displayed onto standard output).
COVERAGE_MESSAGE = "warning: GOCOVERDIR not set, no coverage data emitted"


def filepath_from_context(context: Context, prefix: str = "", suffix: str = "", max_len=200) -> str:
    """Return a filepath like {prefix}{feature_name}_{scenario_name}{suffix}.log.

    If the filepath is longer than $max_len, it's cropped.
    """
    feature_name = context.feature.name.replace("/", "-")
    scenario_name = context.scenario.name.replace("/", "-")
    filepath = f"{prefix}{feature_name}_{scenario_name}{suffix}.log"
    if len(filepath) > max_len:
        filepath = filepath[:max_len]
    return filepath


def process_generated_output(context: Context, out, return_code=None,
                             stdout_file=None, stderr_file=None):
    """Process output generated by finished process."""
    assert out is not None

    # interact with the process:
    # read data from stdout and stderr, until end-of-file is reached
    stdout, stderr = out.communicate()

    # basic checks if process was able to communicate with its parent
    assert stderr is None, "Error during check"
    assert stdout is not None, "No output from process"

    # try to decode output as flow of text lines
    output = stdout.decode("utf-8").split("\n")

    # store the logs in a file if the variable is specified
    if stdout_file is not None and stdout is not None:
        with open(stdout_file, "w") as f:
            f.write(stdout.decode("utf-8"))
    if stderr_file is not None and stderr is not None:
        with open(stderr_file, "w") as f:
            f.write(stderr.decode("utf-8"))

    # filter coverage message
    output = [line for line in output if line != COVERAGE_MESSAGE]

    # check again, just for sure
    assert output is not None

    # check the return code of a process
    # TODO: we will need to support more return codes later
    if return_code:
        assert (
            out.returncode == 0 or out.returncode == return_code
        ), f"Return code is {out.returncode}"

    # update testing context
    context.output = output
    context.stdout = stdout
    context.stderr = stderr

    context.return_code = out.returncode


def filter_coverage_message(output: str) -> str:
    """Filter message about missing GOCOVERDIR etc."""
    return output.replace(COVERAGE_MESSAGE + "\n", "")
